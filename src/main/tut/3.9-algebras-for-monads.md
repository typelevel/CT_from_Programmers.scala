```tut:invisible
// some preparation to make tut happy
trait Comonad[W[_]]
trait Functor[F[_]]
```
```Haskell
alg . return = id
alg . join = alg . fmap alg
```
```scala
alg compose pure == id
alg compose flatten == alg compose fmap(alg)
```
................
```Haskell
foldr :: (a -> a -> a) -> a -> [a] -> a
```
```scala
def foldr[A]
    : (A => A => A) => A => List[A] => A
```
................
```Haskell
foldr f z [x] = x `f` z
```
```tut:silent
def foldr[A]
    : (A => A => A) => A => List[A] => A =
  f => z => {
    case x :: Nil => f(x)(z)
  }
```
................
```Haskell
x `f` z = x
```
```scala
f(x)(z) == x
```
................
```Haskell
h = join . fmap g . f
```
```scala
h == flatten.compose(fmap(g) _ compose f)
```
................
```Haskell
return . f
```
```scala
unit compose f
```
................
```Haskell
data Store s a = Store (s -> a) s
```
```tut:silent
case class Store[S, A](run: S => A, s: S)

// convenient partially applied constructor
object Store {
  def apply[S, A](run: S => A)
      : S => Store[S, A] =
    s => new Store(run, s)
}
```
................
```Haskell
set :: a -> s -> a
get :: a -> s
```
```scala
def set[A, S]: A => S => A
def get[A, S]: A => S
```
................
```Haskell
coalgs a = Store (set a) (get a)
```
```scala
def coalgS[A]: A => Store[S, A] =
  a => Store(set(a), get(a))
```
................
```tut:invisible
// for tut: need both case class and object
object trick {
  object Store {
    def apply[S, A](run: S => A)
        : S => Store[S, A] =
      s => new Store(run, s)
  }
  case class Store[S, A](run: S => A, s: S)
}
import trick._
```
```Haskell
instance Comonad (Store s) where
  extract (Store f s) = f s
  duplicate (Store f s) = Store (Store f) s
```
```tut:silent
implicit def storeComonad[S] =
  new Comonad[({type T[A] = Store[S, A]})#T] {
    def extract[A](wa: Store[S, A])
        : A = wa match {
      case Store(f, s) => f(s)
    }

    def duplicate[A](wa: Store[S, A])
        : Store[S, Store[S, A]] = wa match {
      case Store(f, s) => Store(Store(f), s)
    }
  }
```
................
```Haskell
fmap g (Store f s) = Store (g . f) s
```
```tut:silent
implicit def storeFunctor[S] =
  new Functor[({type T[A] = Store[S, A]})#T] {
    def fmap[A, B](g: A => B)
        (fa: Store[S, A]): Store[S, B] =
      fa match {
        case Store(f, s) =>
          Store(g compose f, s)
      }
  }
```
................
```Haskell
Store (coalg . set a) (get a)
```
```scala
Store(coalg compose set(a), get(a))
```
................
```Haskell
Store (Store (set a)) (get a)
```
```scala
Store(Store(set(a)), get(a))
```
................
```Haskell
coalg (set a s) = Store (set a) s
```
```scala
coalg(set(a)(s)) == Store(set(a))(s)
```
................
```Haskell
Store (set (set a s)) (get (set a s)) = Store (set a) s
```
```scala
Store(set(set(a)(s)))(get(set(a)(s))) ==
  Store(set(a))(s)
```
................
```Haskell
set (set a s) = set a
```
```scala
set(set(a)(s)) == set(a)
```
................
```Haskell
get (set a s) = s
```
```scala
get(set(a)(s)) == s
```
